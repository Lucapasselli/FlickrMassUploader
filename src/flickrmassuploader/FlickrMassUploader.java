/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package flickrmassuploader;

import com.flickr4java.flickr.Flickr;
import com.flickr4java.flickr.FlickrException;
import com.flickr4java.flickr.REST;
import com.flickr4java.flickr.RequestContext;
import com.flickr4java.flickr.auth.Auth;
import com.flickr4java.flickr.auth.AuthInterface;
import com.flickr4java.flickr.auth.Permission;
import com.flickr4java.flickr.photos.Photo;
import com.flickr4java.flickr.photos.PhotoList;
import com.flickr4java.flickr.photosets.Photoset;
import com.flickr4java.flickr.photosets.PhotosetsInterface;
import com.flickr4java.flickr.uploader.UploadMetaData;
import com.flickr4java.flickr.uploader.Uploader;
import static flickrmassuploader.FlickrMassUploader.Nsid;
import static flickrmassuploader.FlickrMassUploader.auth;
import java.awt.Desktop;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;

import org.scribe.model.Token;
import org.scribe.model.Verifier;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.URI;
import java.net.URISyntaxException;
import java.sql.Timestamp;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Properties;
import java.util.concurrent.TimeUnit;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JFileChooser;
import javax.swing.JOptionPane;

/**
 *
 * @author Luca Passelli
 */
public class FlickrMassUploader extends javax.swing.JFrame {

    /**
     * Creates new form FlickrMassUploader
     */
//    static final Logger logger=Logger.getLogger(FlickrMassUploader.class.getName());
    static String apiKey = "";
    static String sharedSecret = "";
    static Flickr flickr;
    static Auth auth;
    static AuthInterface authInterface;
    static String AccessToken = "";
    static String TokenSecret = "";
    static String Nsid;
    static String User="";
    static String Directory = "";
    static String ConfirmationCode = "";
    static Map<String, String> localphotos;
    static Map<String, String> remotephotos;
    static Map<String, String> remotealbums;
    static Map<String, String> localalbums;
    static Map<String, String> phototoupload;
    static backup Backup;
    static Thread process;
    static boolean StopProcess = false;
    static boolean GraphicsOn = true;

    static int sync = 0;
    //sync=o means no sync
    //sync=1 means sync only directorys
    //sync=2 means full sync

    public FlickrMassUploader() {

        File proprieta = new File("config.properties");
        //prima di leggere il file devo verificare se esiste
        if (proprieta.exists()) {
            ReadPropertiesFile();
        }
        initComponents();
        ButtonStop.setVisible(false);
        if (apiKey != null) {
            TextFieldApiKey.setText(apiKey);
        }
        
        if (sharedSecret != null) {
            TextFieldSharedSecret.setText(sharedSecret);
        }
        if (Directory != null) {
            TextFieldPhotoDirectory.setText(Directory);
        }
        //System.out.println(TokenAccesso);
        if (AccessToken != null && TokenSecret != null && !AccessToken.equalsIgnoreCase("") && !TokenSecret.equalsIgnoreCase("")) {
            LabelUser.setText("USER: " + User);
            TextFieldApiKey.setEnabled(false);
            TextFieldSharedSecret.setEnabled(false);
            ButtonRequestToken.setEnabled(false);
        } else {
            ButtonRequestToken.setEnabled(true);
            ButtonUpload.setEnabled(false);
        }
        ComboBoxSyncType.setSelectedIndex(sync);
        String version = this.getClass().getPackage().getImplementationVersion();
        Message("Version : "+version);

    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        ButtonRequestToken = new javax.swing.JButton();
        ButtonUpload = new javax.swing.JButton();
        LabelApiKey = new javax.swing.JLabel();
        LabelSharedSecret = new javax.swing.JLabel();
        TextFieldApiKey = new javax.swing.JTextField();
        TextFieldSharedSecret = new javax.swing.JTextField();
        LabelUser = new javax.swing.JLabel();
        LabelPhotoDirectory = new javax.swing.JLabel();
        TextFieldPhotoDirectory = new javax.swing.JTextField();
        ButtonDeleteCredentials = new javax.swing.JButton();
        ButtonSave = new javax.swing.JButton();
        LabelSyncType = new javax.swing.JLabel();
        ComboBoxSyncType = new javax.swing.JComboBox<>();
        ButtonChooseDirectory = new javax.swing.JButton();
        jScrollPane1 = new javax.swing.JScrollPane();
        TextAreaLog = new javax.swing.JTextArea();
        ButtonStop = new javax.swing.JButton();
        ProgressBarBackup = new javax.swing.JProgressBar();
        LabelStartTime = new javax.swing.JLabel();
        LabelTimeRemaining = new javax.swing.JLabel();
        LabelSyncDescription = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("Flickr Mass Uploader by Luca Passelli");

        ButtonRequestToken.setText("RequestToken");
        ButtonRequestToken.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                ButtonRequestTokenActionPerformed(evt);
            }
        });

        ButtonUpload.setText("Backup Now!");
        ButtonUpload.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                ButtonUploadActionPerformed(evt);
            }
        });

        LabelApiKey.setText("ApiKey:");

        LabelSharedSecret.setText("SharedSecret:");

        LabelUser.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        LabelUser.setText("You don't have a valid Access Token yet, Please request a new Token");

        LabelPhotoDirectory.setText("Photo Directory:");

        ButtonDeleteCredentials.setText("Delete Credentials");
        ButtonDeleteCredentials.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                ButtonDeleteCredentialsActionPerformed(evt);
            }
        });

        ButtonSave.setText("Save");
        ButtonSave.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                ButtonSaveActionPerformed(evt);
            }
        });

        LabelSyncType.setText("Sync Type:");

        ComboBoxSyncType.setModel(new javax.swing.DefaultComboBoxModel<>(new String[] { "no", "Sync", "FullSync" }));
        ComboBoxSyncType.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                ComboBoxSyncTypeActionPerformed(evt);
            }
        });

        ButtonChooseDirectory.setText("Choose Directory");
        ButtonChooseDirectory.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                ButtonChooseDirectoryActionPerformed(evt);
            }
        });

        TextAreaLog.setColumns(20);
        TextAreaLog.setRows(5);
        jScrollPane1.setViewportView(TextAreaLog);

        ButtonStop.setBackground(new java.awt.Color(255, 51, 51));
        ButtonStop.setText("Stop Backup");
        ButtonStop.setEnabled(false);
        ButtonStop.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                ButtonStopActionPerformed(evt);
            }
        });

        ProgressBarBackup.setBackground(new java.awt.Color(204, 255, 204));

        LabelStartTime.setText("Started Time:");

        LabelTimeRemaining.setText("Time Remaining:");

        LabelSyncDescription.setText("SyncDescription");
        LabelSyncDescription.setVerticalAlignment(javax.swing.SwingConstants.TOP);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                                .addGap(59, 59, 59)
                                .addComponent(ButtonStop, javax.swing.GroupLayout.PREFERRED_SIZE, 108, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                .addComponent(ButtonUpload)
                                .addGap(68, 68, 68)
                                .addComponent(ButtonRequestToken)
                                .addGap(80, 80, 80))
                            .addGroup(layout.createSequentialGroup()
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(LabelPhotoDirectory, javax.swing.GroupLayout.PREFERRED_SIZE, 87, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addComponent(LabelApiKey, javax.swing.GroupLayout.PREFERRED_SIZE, 60, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addComponent(LabelSharedSecret, javax.swing.GroupLayout.PREFERRED_SIZE, 90, javax.swing.GroupLayout.PREFERRED_SIZE))
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(TextFieldPhotoDirectory, javax.swing.GroupLayout.DEFAULT_SIZE, 533, Short.MAX_VALUE)
                                    .addComponent(TextFieldApiKey)
                                    .addComponent(TextFieldSharedSecret)
                                    .addComponent(LabelUser, javax.swing.GroupLayout.PREFERRED_SIZE, 448, javax.swing.GroupLayout.PREFERRED_SIZE))))
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createSequentialGroup()
                                .addGap(39, 39, 39)
                                .addComponent(ButtonSave))
                            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(ButtonDeleteCredentials, javax.swing.GroupLayout.Alignment.TRAILING)
                                    .addComponent(ButtonChooseDirectory, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.PREFERRED_SIZE, 121, javax.swing.GroupLayout.PREFERRED_SIZE))))
                        .addGap(17, 17, 17))
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(LabelSyncType, javax.swing.GroupLayout.PREFERRED_SIZE, 97, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                .addComponent(ComboBoxSyncType, javax.swing.GroupLayout.PREFERRED_SIZE, 144, javax.swing.GroupLayout.PREFERRED_SIZE))
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(ProgressBarBackup, javax.swing.GroupLayout.PREFERRED_SIZE, 420, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(LabelStartTime)
                                    .addComponent(LabelTimeRemaining))))
                        .addGap(0, 0, Short.MAX_VALUE))
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                            .addGroup(layout.createSequentialGroup()
                                .addGap(0, 0, Short.MAX_VALUE)
                                .addComponent(LabelSyncDescription, javax.swing.GroupLayout.PREFERRED_SIZE, 511, javax.swing.GroupLayout.PREFERRED_SIZE))
                            .addComponent(jScrollPane1))
                        .addContainerGap())))
        );

        layout.linkSize(javax.swing.SwingConstants.HORIZONTAL, new java.awt.Component[] {ButtonChooseDirectory, ButtonDeleteCredentials, ButtonSave});

        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(25, 25, 25)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(LabelApiKey)
                    .addComponent(TextFieldApiKey, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(ButtonDeleteCredentials))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(LabelSharedSecret)
                    .addComponent(TextFieldSharedSecret, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(LabelUser)
                    .addComponent(ButtonSave))
                .addGap(32, 32, 32)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(TextFieldPhotoDirectory, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(LabelPhotoDirectory)
                    .addComponent(ButtonChooseDirectory))
                .addGap(35, 35, 35)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(3, 3, 3)
                        .addComponent(LabelSyncDescription, javax.swing.GroupLayout.PREFERRED_SIZE, 77, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(18, 18, 18)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(ButtonUpload)
                            .addComponent(ButtonRequestToken))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED))
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(LabelSyncType)
                            .addComponent(ComboBoxSyncType, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(ButtonStop, javax.swing.GroupLayout.PREFERRED_SIZE, 44, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(26, 26, 26)))
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 213, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(ProgressBarBackup, javax.swing.GroupLayout.PREFERRED_SIZE, 27, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                        .addGroup(layout.createSequentialGroup()
                            .addComponent(LabelStartTime)
                            .addGap(22, 22, 22))
                        .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 22, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(LabelTimeRemaining))))
                .addContainerGap(16, Short.MAX_VALUE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void ButtonRequestTokenActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_ButtonRequestTokenActionPerformed

        // TODO add your handling code here:
        //Mi autentico
        AccessToken = "";
        TokenSecret = "";
        apiKey = TextFieldApiKey.getText();
        sharedSecret = TextFieldSharedSecret.getText();
        boolean connectionOK;
        connectionOK = auth();
        //System.out.println(connectionOK);
        if (connectionOK) {
            ButtonRequestToken.setEnabled(false);
            ButtonUpload.setEnabled(true);
            TextFieldApiKey.setEnabled(false);
            TextFieldSharedSecret.setEnabled(false);
            LabelUser.setText("USER: " + User);
        }

    }//GEN-LAST:event_ButtonRequestTokenActionPerformed

    private void ButtonUploadActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_ButtonUploadActionPerformed
        // TODO add your handling code here:
        //Mi autentico
        sync = ComboBoxSyncType.getSelectedIndex();
        Directory = TextFieldPhotoDirectory.getText();
        StopProcess = false;
        boolean connectionOK;
        connectionOK = auth();
        if (connectionOK) {

            Backup = new backup();
            process = new Thread(Backup);
            process.start();

        }

    }//GEN-LAST:event_ButtonUploadActionPerformed

    private void ButtonDeleteCredentialsActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_ButtonDeleteCredentialsActionPerformed
        // TODO add your handling code here:
        TextFieldApiKey.setEnabled(true);
        TextFieldSharedSecret.setEnabled(true);
        TextFieldApiKey.setText("");
        TextFieldSharedSecret.setText("");
        AccessToken = "";
        TokenSecret = "";
        apiKey = "";
        sharedSecret = "";
        LabelUser.setText("Credentials Deleted!, Please request a new Token");
        ButtonUpload.setEnabled(false);
        ButtonRequestToken.setEnabled(true);
    }//GEN-LAST:event_ButtonDeleteCredentialsActionPerformed

    private void ButtonChooseDirectoryActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_ButtonChooseDirectoryActionPerformed
        // TODO add your handling code here:
        JFileChooser fc = new JFileChooser();
        try {
            // TODO add your handling code here:

            fc.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
            File dir = new File(Directory);
            if (Directory != null) {
                fc.setCurrentDirectory(new java.io.File(Directory));
            } else {
                fc.setCurrentDirectory(new java.io.File("."));
            }
            int returnVal = fc.showOpenDialog(this);
            if (returnVal == 0) {
                Directory = fc.getSelectedFile().getCanonicalPath();
                TextFieldPhotoDirectory.setText(Directory);
            }
            //  System.out.println(Directory);
        } catch (IOException ex) {
            Message("Error secting Directory -> " + ex.getMessage());
        } catch (java.lang.InternalError ex) {
            //This error occour when the chooser can't open an existing directory
            //If this occour the chooser must open the root directory
            Message("Error secting Directory -> " + ex.getMessage());
            fc.setCurrentDirectory(new java.io.File("."));
            int returnVal = fc.showOpenDialog(this);
            if (returnVal == 0) {
                try {
                    Directory = fc.getSelectedFile().getCanonicalPath();
                } catch (IOException ex1) {
                    Logger.getLogger(FlickrMassUploader.class.getName()).log(Level.SEVERE, null, ex1);
                }
                TextFieldPhotoDirectory.setText(Directory);
            }
        }
    }//GEN-LAST:event_ButtonChooseDirectoryActionPerformed

    private void ButtonSaveActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_ButtonSaveActionPerformed
        // TODO add your handling code here:
        apiKey = TextFieldApiKey.getText();
        sharedSecret = TextFieldSharedSecret.getText();
        Directory = TextFieldPhotoDirectory.getText();
        sync = ComboBoxSyncType.getSelectedIndex();
        
        WritePropertiesFile();
        JOptionPane.showMessageDialog(null, "Options successfully saved!");

    }//GEN-LAST:event_ButtonSaveActionPerformed

    private void ButtonStopActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_ButtonStopActionPerformed
        // TODO add your handling code here:
        StopProcess = true;

        //Ripristina Interfaccia finita l'esecuzione del software
        while (process.isAlive()) {
            try {
                Thread.sleep(100);
            } catch (InterruptedException ex) {
                Logger.getLogger(FlickrMassUploader.class.getName()).log(Level.SEVERE, null, ex);
            }
        }
        ButtonUpload.setEnabled(true);
        ButtonDeleteCredentials.setEnabled(true);
        ButtonStop.setEnabled(false);
        ButtonStop.setVisible(false);
        JOptionPane.showMessageDialog(null, "BACKUP STOPPED BY USER!!!");

    }//GEN-LAST:event_ButtonStopActionPerformed

    private void ComboBoxSyncTypeActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_ComboBoxSyncTypeActionPerformed
        // TODO add your handling code here:
        if (ComboBoxSyncType.getSelectedIndex() == 0) {
            LabelSyncDescription.setText("<html>With NO option online photos will never be deleted<br>"
                    + "New photos in your computer directory will be uploaded to flickr</html>");
        } else if (ComboBoxSyncType.getSelectedIndex() == 1) {
            LabelSyncDescription.setText("<html>With SYNC option online photos that are no longer present in your local dir will be deleted<br>"
                    + "If exists Photosets online that are not present in your computer will never be deleted<br>"
                    + "The program control the online photosets names with the locals ones<br>"
                    + "New photos in your computer directory will be uploaded to flickr</html>");
        } else if (ComboBoxSyncType.getSelectedIndex() == 2) {
            LabelSyncDescription.setText("<html>With FULLSYNC option online photos that are no longer present in your local dir will be deleted<br>"
                    + "Photos not associated to a Photoset will never be deleted<br>"
                    + "New photos in your computer directory will be uploaded to flickr</html>");
        }
    }//GEN-LAST:event_ComboBoxSyncTypeActionPerformed

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(FlickrMassUploader.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(FlickrMassUploader.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(FlickrMassUploader.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(FlickrMassUploader.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            FlickrMassUploader gr;

            public void run() {
                if (args.length == 0) {
                    new FlickrMassUploader().setVisible(true);
                } else {
                    GraphicsOn = false;
                    if (args[0].equalsIgnoreCase("/backup")) {
                        gr = new FlickrMassUploader();
                        StopProcess = false;
                        boolean connectionOK;
                        connectionOK = gr.auth();
                        if (connectionOK) {
                            gr.BackupYourFiles();
                        }
                        gr.dispose();
                    } else {
                        System.out.println("Please launch program without argument for graphics or with /download argument for batch option");
                    }

                }

            }
        });
    }

    public boolean auth() {

        //If TokenAccesso or TokenSecret are missing then you need to get them
        //else we try to authenticate
        boolean connectionOK = true;
        if (AccessToken == null || TokenSecret == null || AccessToken.equalsIgnoreCase("") || TokenSecret.equalsIgnoreCase("")) {
            connectionOK =FirstAuth();
        } else {
            flickr = new Flickr(apiKey, sharedSecret, new REST());
            //Flickr.debugStream = false;
            authInterface = flickr.getAuthInterface();
            try {
                auth = authInterface.checkToken(AccessToken, TokenSecret);
                Nsid = auth.getUser().getId();
                User = auth.getUser().getUsername();
                // This token can be used until the user revokes it.
                //Message("Token: " + auth.getToken());
                //Message("Secret: " + auth.getTokenSecret());
                //Message("nsid: " + auth.getUser().getId());
                //Message("Realname: " + auth.getUser().getRealName());
                Message("Username: " + auth.getUser().getUsername());
                //Message("Permission: " + auth.getPermission().getType());

            } catch (FlickrException ex) {
                Message("Auth2 error: " + ex.getErrorMessage() + " -> " + ex.getErrorCode());
                // connectionOK=false;
                Message("Request new authentication in progress...");
                //if is not possible to have authentication you need new credentials
                connectionOK = FirstAuth();
                //System.out.println("auth"+connectionOK);
            } catch (com.flickr4java.flickr.FlickrRuntimeException ex) {
                Message("Auth2 error: " + ex.getMessage() + " -> Probably you have no internet connection or the site is not avaiable");
                connectionOK = false;

            }
        }
        return connectionOK;
    }

    public boolean FirstAuth() {
        boolean connectionOK = true;
        //If apiKey or sharedSecret are missing then you need to get them
        //else we try to authenticate
        apiKey = TextFieldApiKey.getText();
        sharedSecret = TextFieldSharedSecret.getText();
        if (apiKey == null || sharedSecret == null || apiKey.equalsIgnoreCase("") || sharedSecret.equalsIgnoreCase("")) {
            //pop up that alert you to insert apikey and shared secret then save
            JOptionPane.showMessageDialog(null, "<html>Please insert apiKey and sharedSecret Values and then Save before proceeding<br>"
                    + "If you don't have any apikey than follow this link <a href=\"url\">https://www.flickr.com/services/apps/create/apply<a><br>"
                    + "and create your own keys</html>");
            connectionOK=false;

        } else {
            flickr = new Flickr(apiKey, sharedSecret, new REST());
            Flickr.debugStream = false;
            authInterface = flickr.getAuthInterface();

            Token token = authInterface.getRequestToken();
            Message("token: " + token);

            String url = authInterface.getAuthorizationUrl(token, Permission.DELETE);
            if (Desktop.isDesktopSupported()) {
                try {
                    Desktop.getDesktop().browse(new URI(url));
                } catch (URISyntaxException ex) {
                    Message("Error Getting URL: " + ex.getMessage());
                } catch (IOException ex) {
                    Message("Error Getting URL: " + ex.getMessage());
                }
            }

            String n = JOptionPane.showInputDialog("Please accept authetincation request from your broswer and then paste here your Confirmation Code:");
            ConfirmationCode = n;
            Message("Pasted Confirmation Code:" + ConfirmationCode);
            String tokenKey = ConfirmationCode;
            if (ConfirmationCode != null) {
                try {
                    Token requestToken = authInterface.getAccessToken(token, new Verifier(tokenKey));
                    auth = authInterface.checkToken(requestToken);
                    // This token can be used until the user revokes it.
                    AccessToken = requestToken.getToken();
                    TokenSecret = requestToken.getSecret();
                    Nsid = auth.getUser().getId();
                    User = auth.getUser().getUsername();
                    //Message("Token: " + requestToken.getToken());
                    //Message("Secret: " + requestToken.getSecret());
                    //Message("nsid: " + auth.getUser().getId());
                    //Message("Realname: " + auth.getUser().getRealName());
                    Message("Username: " + auth.getUser().getUsername());
                    //Message("Permission: " + auth.getPermission().getType());
                    WritePropertiesFile();
                    Message("Authentication success");
                    JOptionPane.showMessageDialog(null, "Authentication Success, now you can upload your files");
                } catch (FlickrException ex) {
                    Message("First Authentication error: " + ex.getErrorMessage() + " -> " + ex.getErrorCode());
                    JOptionPane.showMessageDialog(null, "Confirmation Code:" + ConfirmationCode + " seems to be wrong, please retry the authentication");
                    connectionOK = false;
                } catch (org.scribe.exceptions.OAuthException ex) {
                    Message("First Authentication error: " + ex.getMessage());
                    JOptionPane.showMessageDialog(null, "Confirmation Code:" + ConfirmationCode + " seems to be wrong, please retry the authentication");
                    connectionOK = false;
                }
            } else {
                JOptionPane.showMessageDialog(null, "No Confirmation Code recognized, please retry authentication");
                connectionOK = false;
            }
        }
        return connectionOK;
    }

    private String makeSafeFilename(String input) {
        byte[] fname = input.getBytes();
        byte[] bad = new byte[]{'\\', '/', '"', '*'};
        byte replace = '_';
        for (int i = 0; i < fname.length; i++) {
            for (byte element : bad) {
                if (fname[i] == element) {
                    fname[i] = replace;
                }
            }
            if (fname[i] == ' ') {
                fname[i] = '_';
            }
        }
        String st = new String(fname);
        if (st.length() > 0) {
            //L'eventuale underscore iniziale sul nome lo elimino
            st = st.substring(0, 1).replaceAll("_", "") + st.substring(1);
        }

        return st;
    }

    public String uploadfile(String filename, String TitoloFoto, String Album) throws Exception {
        if (!StopProcess) {
            String photoId;
            // boolean uploadableFile=true;

            UploadMetaData metaData = new UploadMetaData();

            String title = TitoloFoto;
            metaData.setTitle(title);
            metaData.setFilename(TitoloFoto);

            boolean uploadableFile = VerifyExtension(filename);

            if (uploadableFile) {
                Uploader uploader = flickr.getUploader();

                File f = new File(filename);
                photoId = uploader.upload(f, metaData);
                Message(" File : " + filename + " uploaded: photoId = " + photoId);

                /* SimpleDateFormat sdf = new SimpleDateFormat("dd-M-yyyy hh:mm:ss");
	    String dateInString = "31-08-1982 10:20:56";
	    Date date = sdf.parse(dateInString);
            foto.setDateTaken(date);*/
 /* PhotosInterface photoI=flickr.getPhotosInterface();
           photoI.setMeta(foto.getId(), foto.getTitle(), "descrizione di prova");*/
                //Se non esiste un album con quel nome lo creao altrimenti aggiun go la foto a quello esistente
                PhotosetsInterface psi = flickr.getPhotosetsInterface();

                if (remotealbums.get(Album) == null) {
                    Photoset Pset = psi.create(Album, Album, photoId);
                    remotealbums.put(Album, Pset.getId());
                } else {
                    psi.addPhoto(remotealbums.get(Album), photoId);
                }
            } else {
                photoId = null;
            }

            return (photoId);
        } else {
            return null;
        }
    }

    public void RemotePhotoList() {
        // if button stop is pressed StopProcess become true and we have to termiate all tasks
        if (!StopProcess) {
            try {


                PhotosetsInterface psi = flickr.getPhotosetsInterface();
                //create an itarator to list albums
                //sets is the list of albums
                Iterator sets = psi.getList(Nsid).getPhotosets().iterator();

                while (sets.hasNext()) {
                    
                    // if button stop is pressed StopProcess become true and we have to termiate all tasks
                    if (StopProcess) {
                        break;
                    }
                    //Pset it's the selected album
                    Photoset Pset = (Photoset) sets.next();


                    remotealbums.put(Pset.getTitle(), Pset.getId());
                    
                    //photos is the list of photos on selected album
                    PhotoList photos = psi.getPhotos(Pset.getId(), 10000, 1);

                    for (int i = 0; i < photos.size(); i++) {
                        // if button stop is pressed FermaProcessi become true and we have to termiate all tasks
                        if (StopProcess) {
                            break;
                        }
                        //foto is the selected photo
                        Photo foto = (Photo) photos.get(i);
                        remotephotos.put(Pset.getTitle() + "|" + foto.getTitle(), foto.getId());
                    }

                }
            } catch (FlickrException ex) {
                Message("Error getting Photo List on Flickr -> " + ex.getErrorCode() + ":" + ex.getErrorMessage());
            }

        }
    }

    public void BackupYourFiles() {

        // if button stop is pressed StopProcess become true and we have to termiate all tasks
        if (!StopProcess) {
            Message("Directory to sync -> " + Directory);
            if (sync == 0) {
                Message("Sync Type -> NO");
            }
            if (sync == 1) {
                Message("Sync Type -> SYNC");
            }
            if (sync == 2) {
                Message("Sync Type -> FULLSYNC");
            }

            Long InitialTime = System.currentTimeMillis();
            LabelTimeRemaining.setText("Time Remaining:");
            //Long MomentTime;
            remotephotos = new HashMap<>();
            remotealbums = new HashMap<>();
            phototoupload = new HashMap<>();
            localalbums = new HashMap<>();
            localphotos = new HashMap<>();

            //authentication    
            RequestContext rc = RequestContext.getRequestContext();
            rc.setAuth(auth);

            try {
                //Faccio l'elenco degli album e delle foto su flickr

                Message("Retrieving Remote Photo List");
                RemotePhotoList();
                //elenco fotolocali non fa altro che compilare l'hasmap fotolocali con l'elenco delle foto sull'hd
                Message("Retrieving Local Photo List");
                LocalPhotoList(Directory, 0, Directory);

                // albumremoti.forEach((k,v) -> Message("keyR: "+k+" valueR:"+v));
                remotephotos.forEach((k, v)
                        -> {

                    //Se non trovo le foto tra quelle locali e il sync è attivo le cancello
                    if (localphotos.get(k) == null && (sync == 1 || sync == 2)) {
                        //cancello il file solo se l'album è presente tra quelli locali ma la foto non esiste più
                        //oppure è attivo il fullsync

                        if (localalbums.get(k.substring(0, k.indexOf("|"))) != null || sync == 2) {
                            try {
                                // if button stop is pressed FermaProcessi become true and we have to termiate all tasks
                                // in this case we block the online operation
                                if (!StopProcess) {
                                    //Delete photos that are no longer present local
                                    Message("Deleting file " + k + " from the cloud");
                                    flickr.getPhotosInterface().delete(v);
                                }
                            } catch (FlickrException ex) {

                                Message("Error deleting file from flickr -> " + ex.getErrorCode() + ":" + ex.getErrorMessage());
                            }
                        }
                    }
                });

                //Faccio L'elenco delle cartelle e foto locali e per ogni file se non lo trovo
                // Faccio l'upload delle foto se non sono già presenti su flickr
                if (!StopProcess) {
                    localphotos.forEach((k, v)
                            -> {

                        if (remotephotos.get(k) == null) {

                            //se non trovo il corrispondente file locale nel cloud di flickr allora lo carico sul sito
                                phototoupload.put(k, v);
                                //  uploadfile(v, k.substring(k.lastIndexOf("|")+1),k.substring(0,k.lastIndexOf("|")));


                            //La funzione di upload si occuperà del controllo e la gestione degli album
                        } else {
                            //Se il file esiste già sul cloud lo salto e in caso avviso
                            //       System.out.println("File "+v+" already present to the cloud");

                        }
                    });
                }

                int numeroFoto = phototoupload.size();
                if (GraphicsOn) {
                    ProgressBarBackup.setMaximum(numeroFoto);
                    ProgressBarBackup.setValue(0);
                    ProgressBarBackup.setString("0/" + numeroFoto);
                    ProgressBarBackup.setStringPainted(true);
                    LabelStartTime.setText("Started Time: "
                            + String.valueOf(new Timestamp(InitialTime)));
                }
                Message("Number photo on your computer -> " + localphotos.size());
                Message("Number of photo to upload -> " + numeroFoto);

                final int[] count = {0};
                phototoupload.forEach((k, v)
                        -> {
                    count[0]++;

                    try {
                        // if button stop is pressed FermaProcessi become true and we have to termiate all tasks
                        // in this case we block the online operation
                        if (!StopProcess) {

                            Message("Uploading file " + v + " to the cloud " + count[0] + " of " + numeroFoto);
                            uploadfile(v, k.substring(k.lastIndexOf("|") + 1), k.substring(0, k.lastIndexOf("|")));
                            //La funzione di upload si occuperà del controllo e la gestione degli album
                        }
                        if (GraphicsOn) {
                            ProgressBarBackup.setValue(count[0]);
                            ProgressBarBackup.setString(count[0] + "/" + numeroFoto);
                            LabelTimeRemaining.setText("Time Remaining: "
                                    + String.valueOf(TimeUnit.MILLISECONDS.toMinutes(((System.currentTimeMillis() - InitialTime) / (long) count[0]) * (numeroFoto - count[0]))) + " minutes");
                        }
                    } catch (FlickrException ex) {
                        Message("Error uploading file:" + v + "   ->   " + ex.getErrorMessage());
                    } catch (Exception ex) {
                        Message("Error uploading file:" + v + "   ->   " + ex.getMessage());
                    }

                });

            } catch (IOException ex) {
                Message("IO Error   ->   " + ex.getMessage());
            }

        }
        if (StopProcess) {
            Message("Backup Stopped by User!");
            Message("-------------------------------------------------");
            if (GraphicsOn) {
                LabelTimeRemaining.setText("BACKUP STOPPED BY USER!!!");

            }
        } else {
            Message("Backup Finished!");
            Message("-----------------------------------------------");
            if (GraphicsOn) {
                LabelTimeRemaining.setText("BACKUP FINISHED!!!");
                JOptionPane.showMessageDialog(null, "BACKUP FINISHED!!!");
            }
        }
    }

    public void Message(String messaggio) {
        if (GraphicsOn) {
            TextAreaLog.append(String.valueOf(new Timestamp(System.currentTimeMillis()))+" : "+messaggio + "\n");
            TextAreaLog.setCaretPosition(TextAreaLog.getDocument().getLength());

        } else {
            System.out.println(String.valueOf(new Timestamp(System.currentTimeMillis()))+" : "+messaggio);
        }
    }

    public void LocalPhotoList(String dir, int indentamento, String DirRiferimento) throws IOException {
        // if button stop is pressed FermaProcessi become true and we have to termiate all tasks
        if (!StopProcess) {
            int indent;
            File Dir = new File(dir);

            File[] files = Dir.listFiles();
            //devo fare il controllo sull'esistenza dei files prima di procedere perchè ci sono dei file che windows rinomina

            try {
                for (File file : files) {

                    if (file.isDirectory()) {

                        indent = indentamento + 1;
                        //Se l'indentamento è maggiore di 1 la directory di riferimento
                        //che poi sarà il nome dell'album voglio che sia quello della prima cartella
                        //infatti non posso creare album con sotto album
                        //in sostanza se ho una foto sotto ..\sardegna\lunedi\primafoto.jpg
                        //l'album sarà SARDEGNA e il nome della foto sarà lunedi_primafoto.jpg
                        if (indent > 1) {

                            LocalPhotoList(file.getCanonicalPath(), indent, DirRiferimento);
                        } else {

                            LocalPhotoList(file.getCanonicalPath(), indent, file.getCanonicalPath());
                        }
                    } else {
                        if (indentamento == 0) {
                            if (VerifyExtension(file.getCanonicalPath())) {
                                localalbums.put("root", "ok");

                                //Se l'instradamento è zero vuol dire che sono nella root e quindi come album gli do il root
                                localphotos.put("root" + "|" + makeSafeFilename(file.getName()), file.getCanonicalPath());
                            }
                        } else {
                            if (VerifyExtension(file.getCanonicalPath())) {
                                localalbums.put(makeSafeFilename(DirRiferimento.substring(Directory.length())), "ok");
                                //System.out.println(indentamento);
                                // Se l'indentamento è maggiore di uno il nome album è quello della prima cartella e il mome file è l'insieme
                                // del nome delle cartelle successive e il nome file
                                localphotos.put(makeSafeFilename(DirRiferimento.substring(Directory.length())) + "|" + makeSafeFilename(file.getCanonicalPath().substring(DirRiferimento.length())), file.getCanonicalPath());
                            }
                        }

                    }
                }

            } catch (java.lang.NullPointerException ex) {

                Message("Error getting information of folder " + dir + " -> " + ex.getMessage());
            }

        }
    }

    public void WritePropertiesFile() {

        try {
            Properties prop = new Properties();
            OutputStream output = null;
            output = new FileOutputStream("config.properties");

            prop.setProperty("apiKey", apiKey);
            prop.setProperty("sharedSecret", sharedSecret);
            if (AccessToken!=null) prop.setProperty("TokenAccesso", AccessToken);
            if (TokenSecret!=null) prop.setProperty("TokenSecret", TokenSecret);
            prop.setProperty("Directory", Directory);
            prop.setProperty("Sync", String.valueOf(sync));
            if (User!=null) prop.setProperty("User", User);
            //prova
            // save properties to project root folder
            prop.store(output, null);
            output.close();
        } catch (FileNotFoundException ex) {
            Message("Error Writing properties file -> " + ex.getMessage());
        } catch (IOException ex) {
            Message("Error Writing properties file -> " + ex.getMessage());
        }
    }

    public void ReadPropertiesFile() {

        try {
            Properties prop = new Properties();
            InputStream input;
            input = new FileInputStream("config.properties");
            prop.load(input);
            // get properties values
            apiKey = prop.getProperty("apiKey");
            sharedSecret = prop.getProperty("sharedSecret");
            AccessToken = prop.getProperty("TokenAccesso");
            TokenSecret = prop.getProperty("TokenSecret");
            Directory = prop.getProperty("Directory");
            if (prop.getProperty("Sync")!=null)
            sync = Integer.parseInt(prop.getProperty("Sync"));
            else sync=0;
            User = prop.getProperty("User");

            // save properties to project root folder
            input.close();
        } catch (FileNotFoundException ex) {
            Message("Error reading Property file -> " + ex.getMessage());
        } catch (IOException ex) {
            Message("Error reading Property File -> " + ex.getMessage());
        }

    }

    public boolean VerifyExtension(String filename) {
        //Return true only if the extension of the file is supported
        boolean fileok = false;
        String[] SupportedExtensions = new String[]{"jpg", "jpeg", "png", "avi", "mpeg"};
        for (int i = 0; i < SupportedExtensions.length; i++) {
            String suffix = makeSafeFilename(filename).substring(makeSafeFilename(filename).lastIndexOf('.') + 1);
            if (suffix.equalsIgnoreCase(SupportedExtensions[i])) {
                fileok = true;
            }
        }
        return fileok;

    }

    public class backup implements Runnable {
//class to make the backup stoppable
        //  private boolean isInterrupted = false;
        // boolean interrotto=false;

        public void run() {

            /*  if(Thread.currentThread().isInterrupted()) {
            // if interrupt is not overrided, isInterrupted would return
           // false and the thread would continue to run. 
            return;
        }*/
            //Grayout alla buttons eccept the Stop thread Button
            ButtonUpload.setEnabled(false);
            ButtonDeleteCredentials.setEnabled(false);
            ButtonStop.setEnabled(true);
            ButtonStop.setVisible(true);

            BackupYourFiles();
            //BACKUP YOU FILES FUCTION CLONE
            //authentication           

            //Ripristina Interfaccia finita l'esecuzione del software
            ButtonUpload.setEnabled(true);
            ButtonDeleteCredentials.setEnabled(true);
            ButtonStop.setEnabled(false);
            ButtonStop.setVisible(false);

        }
        /* @Override
    public boolean isInterrupted() {
        return isInterrupted;
    }
         */

 /* @Override
        public void interrupt(){
       //Ripristina interfaccia
       ButtonUpload.setEnabled(true);
       ButtonChooseDirectory.setEnabled(true);
       ButtonDeleteCredentials.setEnabled(true);
       ButtonRequestToken.setEnabled(true);
       ButtonSave.setEnabled(true);
       
       isInterrupted = true;
       super.interrupt();
     
    }*/
 /*public void ferma(){
         interrotto=true;
     }*/
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton ButtonChooseDirectory;
    private javax.swing.JButton ButtonDeleteCredentials;
    private javax.swing.JButton ButtonRequestToken;
    private javax.swing.JButton ButtonSave;
    private javax.swing.JButton ButtonStop;
    private javax.swing.JButton ButtonUpload;
    private javax.swing.JComboBox<String> ComboBoxSyncType;
    private javax.swing.JLabel LabelApiKey;
    private javax.swing.JLabel LabelPhotoDirectory;
    private javax.swing.JLabel LabelSharedSecret;
    private javax.swing.JLabel LabelStartTime;
    private javax.swing.JLabel LabelSyncDescription;
    private javax.swing.JLabel LabelSyncType;
    private javax.swing.JLabel LabelTimeRemaining;
    private javax.swing.JLabel LabelUser;
    private javax.swing.JProgressBar ProgressBarBackup;
    private javax.swing.JTextArea TextAreaLog;
    private javax.swing.JTextField TextFieldApiKey;
    private javax.swing.JTextField TextFieldPhotoDirectory;
    private javax.swing.JTextField TextFieldSharedSecret;
    private javax.swing.JScrollPane jScrollPane1;
    // End of variables declaration//GEN-END:variables
}
